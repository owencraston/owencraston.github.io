{
    "componentChunkName": "component---src-templates-blogs-post-js",
    "path": "/post-2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Owen Craston"}},"markdownRemark":{"id":"d92e789b-c05d-592a-be8a-c92f8e6d943a","excerpt":"Recently, I have been using a lot more data structures in Kotlin and I found there was a lack of information for Kotlin vs its older brother…","rawMarkdownBody":"\nRecently, I have been using a lot more data structures in Kotlin and I found there was a lack of information for `Kotlin` vs its older brother `Java`. In this blog post,  I have tried to compile a list of common data structures with their runtimes and syntax in Kotlin. \nIt's worth noting that because `Kotlin is backward-compatible with Java`, all the [same collections from Java](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html) can be used. The main difference between [Kotlin collections](https://kotlinlang.org/docs/collections-overview.html) and their Java counterpart, is the concept of a [mutable collection](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-collection/). `Immutable collections are read only` whereas the mutable collections allow for adding, removing and updating elements within it. Since `mutable` collections are inherently ...mutable... they do not need to be instantiated with `var` as the reference will not be changing - only the contents of the collection will change.\n\n# Arrays\n[Arrays in Kotlin](https://kotlinlang.org/docs/basic-types.html#arrays) are a primitive data structure that are fixed in size, and allow for getting and setting values in constant time.\n\n## Creating an Array\n\n### Using `arrayOf`\n- Pass in the values for the array and the array will be created with the proper size, type and elements\n- Use `arrayOfNulls` to create an array of a given size with all null values\n```kotlin\n\t// Create an array with values\n\tval nums1 = arrayOf(1, 2, 3, 4) //implicit type declaration\n\tval nums2 = arrayOf<Int>(1, 2, 3) //explicit type declaration\n\t// Create an Array<Int?> of size 4 with values [null, null, null, null]\n\tval nulls: Array<Int?> = arrayOfNulls<Int>(4)\n```\n### Using the Array `constructor`\n- Pass in the size of the array\n- Pass a function that returns the array value given an index \n\n```kotlin\n\t// Creates an Array<Int> with values [0, 1, 2, 3, 4]\n\tval nums = Array(5) { i -> i}\n\t// Creates an Array<String> with values [\"0\", \"1\", \"4\", \"9\", \"16\"]\n\tval strings = Array(5) { i -> (i * i).toString() }\n```\n# Primitive Arrays\nKotlin also provides Array classes for primitives that can offer some nice syntax. The options are the following:\n- ByteArray\n- CharArray\n- ShortArray\n- IntArray\n- LongArray\n- DoubleArray\n- FloatArray\n- BooleanArray\n\nThese arrays can be created by passing the values of the array, the size of the array or the size and a lambda expression.\n```kotlin\n\t// Array of int of size 3 with values [1, 2, 3]\n\tvar arr1 =  intArrayOf(1, 2, 3)\n\t// Array of booleans of size 3 with values [true, false, true]\n\tvar arr2 =  booleanArrayOf(true, false, true)\n\t// Array of int of size 5 with values [0, 0, 0, 0, 0]\n\tval arr3 = IntArray(5)\n\t// Array of chars of size 5 with values [, , , , ]\n\tval arr4 = CharArray(5)\n\t// Array of int of size 5 with values [42, 42, 42, 42, 42]  \n\tval arr5 =  IntArray(5)  {  42  }\n\t// Array of int of size 5 with values [0, 1, 2, 3, 4] \n\t// (values initialised to their index value)  \n\tvar arr6 =  IntArray(5)  { it -> it  }\n```\n\n ## Array Methods and Runtimes\n\n| Action                | Method                  | Time Complexity | Alternative          |\n|-----------------------|-------------------------|---------|----------------------|\n| Access value at index | array.get(index)        | O(1)    | array[index]         |\n| Set value at index    | array.set(index, value) | O(1)    | array[index] = value |\n| Sort array in place by natural order    | array.sort() | O(nlogn)    | |\n| Sort array in place in reverse order    | array.sortDescending()| O(nlogn)    | |\n\n# Lists\nSimilar to the [Java list](https://docs.oracle.com/javase/8/docs/api/java/util/List.html), the [Kotlin List](https://kotlinlang.org/docs/collections-overview.html#list) is an interface that allows for the storage of elements in a specified order, with indexed access to these elements. It also allows for the growing and shrinking of the list, given it is mutable. The default implementation of `List` in Kotlin is an [ArrayList](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-list/) but others are available. \n\n## Creating A List\n### A `read only` list can be created using the `listOf()` function.\n```kotlin\nval numbers = listOf(\"one\", \"two\", \"three\", \"four\") //implicit type declaration\nval numbers2 = listOf<String>(\"one\", \"two\", \"three\", \"four\") // explicit type declaration\n```\n### A mutable list can be created using `mutableListOf()`\n```kotlin\nval numbers = mutableListOf(1, 2, 3, 4) //implicit type declaration\nval numbers2 = mutableListOf<Int>(1, 2, 3, 4) // explicit type declaration\n```\n## List Methods and Runtimes\n| Action                                                                                                                                                      | Method                                                                                  | Runtime                                                                                                                          |\n|-------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| Get the size of the list                                                                                                                                    | list.size                                                                               | O(1)                                                                                                                             |\n| Add element to list                                                                                                                                         | list.add(element)                                                                       | O(1) unless a new backing array needs to be created. In this case all the old values will need to be copied over making it O(n)  |\n| Add element at index                                                                                                                                        | list.add(index, element)                                                                | O(n)                                                                                                                             |\n| Get element at index                                                                                                                                        | list.get(index)                                                                         | O(1)                                                                                                                             |\n| Remove a specific element                                                                                                                                   | list.remove(element)                                                                    | O(n)                                                                                                                             |\n| Remove an element at a specific index                                                                                                                       | list.removeAt(index)                                                                    | O(n)                                                                                                                             |\n| Get the index of a specific element                                                                                                                         | list.indexOf(element)                                                                   | O(n)                                                                                                                             |\n| Check if the list contains an element                                                                                                                       | list.contains(element)                                                                  | O(n)                                                                                                                             |\n| Check if the list is null or empty                                                                                                                          | list.isNullOrEmpty()                                                                    | O(1)                                                                                                                             |\n| randomly shuffle list in place                                                                                                                              | list.shuffle()                                                                          | O(n)                                                                                                                             |\n| return randomly shuffled version of a list                                                                                                                  | val shuffled = list.shuffled()                                                          | O(n)                                                                                                                             |\n| sort list in place by natural order                                                                                                                         | list.sort()                                                                             | O(nlogn)                                                                                                                         |\n| return sorted list by natural order                                                                                                                         | val s = list.sorted()                                                                   | O(nlogn)                                                                                                                         |\n| sort list in place in descending order                                                                                                                      | list.sortByDescending{ it }                                                             | O(nlogn)                                                                                                                         |\n| return sorted list in descending order                                                                                                                      | val s = list.sortedByDescending{ it }                                                   | O(nlogn)                                                                                                                         |\n| sort list in place according to its natural order based on the returned property of the expression. This can be used to sort objects by a certain property. | val values = mutableListOf(1 to \"a\", 2 to \"b\")  values.sortBy { it.second }             | O(nlogn)                                                                                                                         |\n| return sorted list according to its natural order based on the returned property of the expression. This can be used to sort objects by a certain property. | val values = mutableListOf(1 to \"a\", 2 to \"b\") val sorted = values.sortBy { it.second } | O(nlogn)                                                                                                                         |\n| Return a read only view of a portion of a list from starting index (inclusive) until end index (exclusive)                                                  | val list =  listOf(1, 2, 3, 4, 5) val s = list.subList(2, 4) // [3, 4]                  | O(1) since its backed by the source array                                                                                        |\n| Return list as an array                                                                                                                                     | val arr = list.toTypedArray()                                                                | O(n)                                                                                                                             |\n\n# Linked List\nThis data structure is rarely used and for this reason Kotlin has opted to not implement it. [Here](https://discuss.kotlinlang.org/t/why-kotlin-does-not-provide-linkedlist-implementation/15991) is a thread on why they opted to not support it natively although it's still possible to achieve this functionality using the [Java LinkedList](https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html). It is worth noting that this class is a [doubly linked list](https://en.wikipedia.org/wiki/Doubly_linked_list).\n\n## Creating a Linked List\n### Importing `import java.util.LinkedList` allows for instantiating it as would any other class.\n```kotlin\nimport java.util.LinkedList\nval list = listOf(\"Dog\", \"Cat\", \"Lion\")\nval linkedList =  LinkedList<String>()\nlinkedList.addAll(list) \nprintln(linkedList) // [Dog, Cat, Lion]\nlinkedList.add(\"Parrot\")\nprintln(linkedList) // [Dog, Cat, Lion, Parrot]\n```\n## Linked List Methods and Runtimes\n| Action                                             | Method                         | Runtime                              |\n|----------------------------------------------------|--------------------------------|--------------------------------------|\n| Append element to the end of the linked list       | linkedList.add(element)        | O(1)                                 |\n| Add element at a specific index in the linked list | linkedList.add(index, element) | O(n)                                 |\n| Get element at index in the linked list            | linkedList.get(index)          | O(n)                                 |\n| Remove an element from the linked list             | linkedList.remove(element)     | O(1)                                 |\n| Remove element at a specific index                 | linkedList.removeAt(index)     | O(n)                                 |\n| Check if a linked list contains an element         | linkedList.contains(element)   | O(n)                                 |\n| Return the linked list in reverse order            | val r = linkedList.reversed()  | O(1) since the list is doubly linked |\n\n# Set\nA [Set](https://kotlinlang.org/docs/collections-overview.html#set) stores unique elements. Like all collections in Kotlin, there are the [read only set](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/) and the [MutableSet](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/), which offers write access. In some cases the order of a set is not reliable, that is to say that the order of insertion is not maintained. However, the default implementation of a set in Kotlin uses a [LinkedHashSet](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/) so the order of insertion is preserved.\n\n## Creating a Set\n### A `read only` set can be created using the `setOf` function\n```kotlin\nval mySet = setOf(1, 2, 3, 4) //implicit type declaration\nval mySet2 = setOf<Int>(1, 2, 3, 4) // explicit type declaration\n```\n### A mutable set can be created using the `mutableSetOf` function\n```kotlin\nval mySet = mutableSetOf(1, 2, 3, 4) //implicit type declaration\nval mySet2 = mutableSetOf<Int>(1, 2, 3, 4) // explicit type declaration\nmySet.add(5)\nmySet.add(3)\nprintln(mySet2) // [1, 2, 3, 4, 5], notice how 4 was not added twice\n```\n\n## Set Methods and Runtimes\n| Action                             | Method                  | Runtime |\n|------------------------------------|-------------------------|---------|\n| Get the size of the set            | mySet.size              | O(1)    |\n| Add element to the set             | mySet.add(element)      | O(1)    |\n| Remove element from set            | mySet.remove(element)   | O(1)    |\n| Check if a set contains an element | mySet.contains(element) | O(1)    |\n\n# Map\nA [Map](https://kotlinlang.org/docs/collections-overview.html#map) stores key-value pairs with unique keys. Values in the map can be stored more than once if they are stored under different keys. Similarly to the set, some implementations of this `interface` do not preserve order, however, the default implementation of [LinkedHashMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/) does.\n\n## Creating a Map\n###  A `read only` map can be created using the `mapOf` function\n#### A map will always have a `type for the key` and a `type for the value` so it's important to be mindful of that when explicitly declaring a map.\n```kotlin\nval numsMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3) //implicit type declaration\nval numsMap2 = mapOf<String, Int>(\"one\" to 1, \"two\" to 2, \"three\" to 3) // explicit type declaration\n// The above will create a map of type <String, Int> with the key/values {one=1, two=2, three=3}\n```\n### A mutable map can be created using the `mutableMapOf` function\n```kotlin\nval numsMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3) //implicit type declaration\nval numsMap2 = mutableMapOf<String, Int>(\"one\" to 1, \"two\" to 2, \"three\" to 3) // explicit type \nprintln(numsMap) // {one=1, two=2, three=3}\nnumsMap.put(\"five\", 5) // add an entry\nprintln(numsMap) // {one=1, two=2, three=3, five=5}\nprintln(numsMap.get(\"three\")) // 3\nnumsMap.remove(\"one\") // remove an enrty\nprintln(numsMap) // {two=2, three=3, five=5}\n```\n\n## Map Methods and Runtimes\n| Action                          | Method                     | Runtime | Alternative                          |\n|---------------------------------|----------------------------|---------|--------------------------------------|\n| Get the size of the map         | myMap.size                 | O(1)    |                                      |\n| Add/modify an entry to the map  | myMap.put(key, value)      | O(1)    | myMap[key] = value                   |\n| Remove an entry from the map    | myMap.remove(key)          | O(1)    |                                      |\n| Check if map contains a key     | myMap.contains(key)        | O(1)    | myMap.contains(key).let {...}        |\n| Check if a map contains a value | myMap.containsValue(value) | O(n)    | myMap.containsValue(value).let {...} |\n\n# Heap\n[Heaps](https://en.wikipedia.org/wiki/Heap_(data_structure)) are great! There are generally two types of heaps. A min heap which stores the minimum element at the root of the tree, and a max heap which instead stores the largest value at the root. In Kotlin, we can leverage the [PriorityQueue](https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html) to create this data structure. \n\n## Creating a Min Heap with a Priority Queue\nThe default implementation of a PriorityQueue actually gives the min heap functionality. Since Kotlin does not support this out of the box, it's necessary to `import java.util.PriorityQueue`. Once PriorityQueue is imported, one can be declared as such:\n\n```kotlin\nimport java.util.PriorityQueue\n\nval nums = listOf(5, 2, 4, 1, 3)\nval minHeap = PriorityQueue<Int>() // declare a min heap with int values\nminHeap.addAll(nums) // add elements of a Collection with addAll assuming they are the same type\nprintln(minHeap) // [1, 2, 4, 5, 3]\nminHeap.add(0)\nprintln(minHeap) // [0, 2, 1, 5, 3, 4]\nval min = minHeap.poll() // 0, removes 0 from the heap\nprintln(minHeap) // [1, 2, 4, 5, 3] since 1 is not the smallest value\nval min2 = minHeap.peek() // returns 1 but does not remove it from the heap\nprintln(min2) // 1\nprintln(minHeap) // [1, 2, 4, 5, 3]\n```\n\n## Creating a Max Heap with a PriorityQueue\nTo turn the PriorityQueue into a max heap, it will be required to pass an instance of [comparator](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/). Luckily, most of the common comparators can be found [here](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/). The one that will enable the max heap functionality is the [compareByDescending](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/compare-by-descending.html#comparebydescending) function. This will tell the PriorityQueue to give the highest priority to the largest value.\n\n```kotlin\nimport java.util.PriorityQueue\nval nums = listOf(5, 2, 4, 1, 3)\nval maxHeap = PriorityQueue<Int>(compareByDescending{it})\nmaxHeap.addAll(nums)\nprintln(maxHeap) // [5, 3, 4, 1, 2]\nmaxHeap.add(0)\nprintln(maxHeap) // [5, 3, 4, 1, 2, 0]\nval max = maxHeap.poll() // returns and removes 5 from the heap\nprintln(max) // 5\nprintln(maxHeap) // [4, 3, 0, 1, 2]\nval max2 = maxHeap.peek()  // returns 4 but does not remove it from the heap\nprintln(max2) // 4\nprintln(maxHeap) // [4, 3, 0, 1, 2]\n```\n\n## Heap (PriorityQueue) Methods and Runtimes\n| Action                                                             | Method                 | Runtime                                           |\n|--------------------------------------------------------------------|------------------------|---------------------------------------------------|\n| Get the size of the heap                                           | heap.size              | O(1)                                              |\n| Add element to heap                                                | heap.add(element)      | O(logn)                                           |\n| Add a collection of elements to a heap (does not work with arrays) | heap.addAll(list)      | O(nlogn)                                          |\n| Return and remove the root of the heap (min/max value)             | heap.poll()            | O(logn) since we will need to re heapify the heap |\n| Return the root of the heap (min/max)                              | heap.peek()            | O(1) as no reconstruction is needed               |\n| Remove a specific element from the heap                            | heap.remove(element)   | O(n)                                              |\n| Check if an element is present in the heap                         | heap.contains(element) | O(n)                                              |\n\n# Stacks\nA [Stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) is a `last in, first out`, or `LIFO` for short, data structure. It can be thought of as a stack of plates, where the first plate grabbed is going to be the top-most plate (the one that was added last). Again, Kotlin does not provide an implementation of this out of the box so we must rely on its older brother Java. Java has a [Stack](https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html) class but as per the documentation, it is recommended to use an [ArrayDeque](https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html) for all stack/queue needs. More information on this decision can be found in [this thread](https://stackoverflow.com/questions/12524826/why-should-i-use-deque-over-stack). Importing`import java.util.ArrayDeque` is all that's needed to get started.\n\n## Creating a Stack\n### ArrayDeque can be used for both `LIFI` and `FIFO` (first-in & first-out) structures. By always pushing/popping from the front of the stack it's possible to achieve the desired stack behaviour. \n```kotlin\nimport java.util.ArrayDeque\n\nval stack = ArrayDeque<Int>()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nstack.push(4)\nprintln(stack)           // [4, 3, 2, 1]\nprintln(stack.isEmpty()) // false\nprintln(stack.peek())    // 4\nprintln(stack)           // [4, 3, 2, 1]\nprintln(stack.pop())     // 4\nprintln(stack)           // [3, 2, 1]\nstack.push(9)\nprintln(stack)           // --> [9, 3, 2, 1]\n```\n\n## Stack (ArrayDeque) Methods and Runtimes\n| Action                                                 | Method                | Runtime |\n|--------------------------------------------------------|-----------------------|---------|\n| Get the size of the stack                              | stack.size            | O(1)    |\n| Push element onto the stack                            | stack.push(element)   | O(1)    |\n| Return and remove a the last element from the stack    | stack.pop()           | O(1)    |\n| Return the last element from the stack (do not remove) | stack.peek()          | O(1)    |\n| Remove a specific element from the stack               | stack.remove(element) | O(n)    |\n| Check if the stack is empty                            | stack.isEmpty()       | O(1)    |\n\n# Queue\n### A queue is a `first in first out` or `FIFO` for short, data structure, and can be thought of as the average lineup to get into a concert. The first to get there is the first to get out of the queue. [Queue](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html) is an interface that can be implemented by either [ArrayDeque](https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html), [PriorityQueue](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html) or [LinkedList](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html) (there are more options but these are by far the most common). \n\n## Creating a Queue\n### Since PriorityQueue will unnecessarily add extra functionality (see heap section above) and the LinkedList is not very cache-friendly, it is advised to use `ArrayDeque` to implement a queue. To get started importing `import java.util.Queue` and `import java.util.ArrayDeque` is required.\n\n```kotlin\nimport java.util.ArrayDeque\nimport java.util.Queue\nval queue: Queue<Int> = ArrayDeque<Int>()\nqueue.add(1)\nqueue.add(2)\nqueue.add(3)\nqueue.add(4)\nprintln(queue) // [1, 2, 3, 4]    \nprintln(queue.isEmpty()) // false\nprintln(queue.peek()) // 1\nprintln(queue) // [1, 2, 3, 4]      \nprintln(queue.poll()) // 1  \nprintln(queue) // [2, 3, 4]\nqueue.add(9) \nprintln(queue) // [2, 3, 4, 9]\n```\nBy implementing the interface `Queue`, there will no longer be access to the methods `push` and `pop` like there were in the `stack` example above.\n\n## Queue Methods and Runtimes\n| Action                                                  | Method                                     | Runtime |\n|---------------------------------------------------------|--------------------------------------------|---------|\n| Get the size of the queue                               | queue.size                                 | O(1)    |\n| Add element to the queue                                | queue.add(element) or queue.offer(element) | O(1)    |\n| Return and remove a the first element from the queue    | queue.poll()                               | O(1)    |\n| Return the first element from the queue (do not remove) | queue.peek()                               | O(1)    |\n| Remove a specific element from the queue                | queue.remove(element)                      | O(n)    |\n| Check if the stack is empty                             | queue.isEmpty()                            | O(1)    |\n\n# Undirected Graphs\nThere is no default Graph implementation in Kotlin, however, one can easily be createdusing a [HashMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-map/) of [HashSets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-set/). Essentially, the adjacency list is stored in a HashMap, which holds a HashSet of nodes.\n\n## Creating a Graph\n```kotlin\nclass Graph<T> {\n    val adjacencyMap: HashMap<T, HashSet<T>> = HashMap()\n    fun addEdge(sourceVertex: T, destinationVertex: T) {\n        // Add edge to source vertex / node.\n        adjacencyMap\n            .computeIfAbsent(sourceVertex) { HashSet() }\n            .add(destinationVertex)\n        // Add edge to destination vertex / node.\n        adjacencyMap\n            .computeIfAbsent(destinationVertex) { HashSet() }\n            .add(sourceVertex)\n    }\n}\n```\nThe `computeIfAbsent` will create the edge if it is not present, and add the vertex to that edge. Since it's using maps/sets behind the scenes, the runtime for adding an edge remains constant with `O(1)` insertion.\n","html":"<p>Recently, I have been using a lot more data structures in Kotlin and I found there was a lack of information for <code>Kotlin</code> vs its older brother <code>Java</code>. In this blog post,  I have tried to compile a list of common data structures with their runtimes and syntax in Kotlin.\nIt’s worth noting that because <code>Kotlin is backward-compatible with Java</code>, all the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html\">same collections from Java</a> can be used. The main difference between <a href=\"https://kotlinlang.org/docs/collections-overview.html\">Kotlin collections</a> and their Java counterpart, is the concept of a <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-collection/\">mutable collection</a>. <code>Immutable collections are read only</code> whereas the mutable collections allow for adding, removing and updating elements within it. Since <code>mutable</code> collections are inherently …mutable… they do not need to be instantiated with <code>var</code> as the reference will not be changing - only the contents of the collection will change.</p>\n<h1>Arrays</h1>\n<p><a href=\"https://kotlinlang.org/docs/basic-types.html#arrays\">Arrays in Kotlin</a> are a primitive data structure that are fixed in size, and allow for getting and setting values in constant time.</p>\n<h2>Creating an Array</h2>\n<h3>Using <code>arrayOf</code></h3>\n<ul>\n<li>Pass in the values for the array and the array will be created with the proper size, type and elements</li>\n<li>Use <code>arrayOfNulls</code> to create an array of a given size with all null values</li>\n</ul>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">\t// Create an array with values\n\tval nums1 = arrayOf(1, 2, 3, 4) //implicit type declaration\n\tval nums2 = arrayOf&lt;Int&gt;(1, 2, 3) //explicit type declaration\n\t// Create an Array&lt;Int?&gt; of size 4 with values [null, null, null, null]\n\tval nulls: Array&lt;Int?&gt; = arrayOfNulls&lt;Int&gt;(4)</code>\n        </deckgo-highlight-code>\n<h3>Using the Array <code>constructor</code></h3>\n<ul>\n<li>Pass in the size of the array</li>\n<li>Pass a function that returns the array value given an index</li>\n</ul>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">\t// Creates an Array&lt;Int&gt; with values [0, 1, 2, 3, 4]\n\tval nums = Array(5) { i -&gt; i}\n\t// Creates an Array&lt;String&gt; with values [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]\n\tval strings = Array(5) { i -&gt; (i * i).toString() }</code>\n        </deckgo-highlight-code>\n<h1>Primitive Arrays</h1>\n<p>Kotlin also provides Array classes for primitives that can offer some nice syntax. The options are the following:</p>\n<ul>\n<li>ByteArray</li>\n<li>CharArray</li>\n<li>ShortArray</li>\n<li>IntArray</li>\n<li>LongArray</li>\n<li>DoubleArray</li>\n<li>FloatArray</li>\n<li>BooleanArray</li>\n</ul>\n<p>These arrays can be created by passing the values of the array, the size of the array or the size and a lambda expression.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">\t// Array of int of size 3 with values [1, 2, 3]\n\tvar arr1 =  intArrayOf(1, 2, 3)\n\t// Array of booleans of size 3 with values [true, false, true]\n\tvar arr2 =  booleanArrayOf(true, false, true)\n\t// Array of int of size 5 with values [0, 0, 0, 0, 0]\n\tval arr3 = IntArray(5)\n\t// Array of chars of size 5 with values [, , , , ]\n\tval arr4 = CharArray(5)\n\t// Array of int of size 5 with values [42, 42, 42, 42, 42]  \n\tval arr5 =  IntArray(5)  {  42  }\n\t// Array of int of size 5 with values [0, 1, 2, 3, 4] \n\t// (values initialised to their index value)  \n\tvar arr6 =  IntArray(5)  { it -&gt; it  }</code>\n        </deckgo-highlight-code>\n<h2>Array Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Time Complexity</th>\n<th>Alternative</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Access value at index</td>\n<td>array.get(index)</td>\n<td>O(1)</td>\n<td>array[index]</td>\n</tr>\n<tr>\n<td>Set value at index</td>\n<td>array.set(index, value)</td>\n<td>O(1)</td>\n<td>array[index] = value</td>\n</tr>\n<tr>\n<td>Sort array in place by natural order</td>\n<td>array.sort()</td>\n<td>O(nlogn)</td>\n<td></td>\n</tr>\n<tr>\n<td>Sort array in place in reverse order</td>\n<td>array.sortDescending()</td>\n<td>O(nlogn)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h1>Lists</h1>\n<p>Similar to the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/List.html\">Java list</a>, the <a href=\"https://kotlinlang.org/docs/collections-overview.html#list\">Kotlin List</a> is an interface that allows for the storage of elements in a specified order, with indexed access to these elements. It also allows for the growing and shrinking of the list, given it is mutable. The default implementation of <code>List</code> in Kotlin is an <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-list/\">ArrayList</a> but others are available.</p>\n<h2>Creating A List</h2>\n<h3>A <code>read only</code> list can be created using the <code>listOf()</code> function.</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">val numbers = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) //implicit type declaration\nval numbers2 = listOf&lt;String&gt;(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) // explicit type declaration</code>\n        </deckgo-highlight-code>\n<h3>A mutable list can be created using <code>mutableListOf()</code></h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">val numbers = mutableListOf(1, 2, 3, 4) //implicit type declaration\nval numbers2 = mutableListOf&lt;Int&gt;(1, 2, 3, 4) // explicit type declaration</code>\n        </deckgo-highlight-code>\n<h2>List Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Runtime</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get the size of the list</td>\n<td>list.size</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Add element to list</td>\n<td>list.add(element)</td>\n<td>O(1) unless a new backing array needs to be created. In this case all the old values will need to be copied over making it O(n)</td>\n</tr>\n<tr>\n<td>Add element at index</td>\n<td>list.add(index, element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get element at index</td>\n<td>list.get(index)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Remove a specific element</td>\n<td>list.remove(element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Remove an element at a specific index</td>\n<td>list.removeAt(index)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get the index of a specific element</td>\n<td>list.indexOf(element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Check if the list contains an element</td>\n<td>list.contains(element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Check if the list is null or empty</td>\n<td>list.isNullOrEmpty()</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>randomly shuffle list in place</td>\n<td>list.shuffle()</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>return randomly shuffled version of a list</td>\n<td>val shuffled = list.shuffled()</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>sort list in place by natural order</td>\n<td>list.sort()</td>\n<td>O(nlogn)</td>\n</tr>\n<tr>\n<td>return sorted list by natural order</td>\n<td>val s = list.sorted()</td>\n<td>O(nlogn)</td>\n</tr>\n<tr>\n<td>sort list in place in descending order</td>\n<td>list.sortByDescending{ it }</td>\n<td>O(nlogn)</td>\n</tr>\n<tr>\n<td>return sorted list in descending order</td>\n<td>val s = list.sortedByDescending{ it }</td>\n<td>O(nlogn)</td>\n</tr>\n<tr>\n<td>sort list in place according to its natural order based on the returned property of the expression. This can be used to sort objects by a certain property.</td>\n<td>val values = mutableListOf(1 to “a”, 2 to “b”)  values.sortBy { it.second }</td>\n<td>O(nlogn)</td>\n</tr>\n<tr>\n<td>return sorted list according to its natural order based on the returned property of the expression. This can be used to sort objects by a certain property.</td>\n<td>val values = mutableListOf(1 to “a”, 2 to “b”) val sorted = values.sortBy { it.second }</td>\n<td>O(nlogn)</td>\n</tr>\n<tr>\n<td>Return a read only view of a portion of a list from starting index (inclusive) until end index (exclusive)</td>\n<td>val list =  listOf(1, 2, 3, 4, 5) val s = list.subList(2, 4) // [3, 4]</td>\n<td>O(1) since its backed by the source array</td>\n</tr>\n<tr>\n<td>Return list as an array</td>\n<td>val arr = list.toTypedArray()</td>\n<td>O(n)</td>\n</tr>\n</tbody>\n</table>\n<h1>Linked List</h1>\n<p>This data structure is rarely used and for this reason Kotlin has opted to not implement it. <a href=\"https://discuss.kotlinlang.org/t/why-kotlin-does-not-provide-linkedlist-implementation/15991\">Here</a> is a thread on why they opted to not support it natively although it’s still possible to achieve this functionality using the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html\">Java LinkedList</a>. It is worth noting that this class is a <a href=\"https://en.wikipedia.org/wiki/Doubly_linked_list\">doubly linked list</a>.</p>\n<h2>Creating a Linked List</h2>\n<h3>Importing <code>import java.util.LinkedList</code> allows for instantiating it as would any other class.</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">import java.util.LinkedList\nval list = listOf(&quot;Dog&quot;, &quot;Cat&quot;, &quot;Lion&quot;)\nval linkedList =  LinkedList&lt;String&gt;()\nlinkedList.addAll(list) \nprintln(linkedList) // [Dog, Cat, Lion]\nlinkedList.add(&quot;Parrot&quot;)\nprintln(linkedList) // [Dog, Cat, Lion, Parrot]</code>\n        </deckgo-highlight-code>\n<h2>Linked List Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Runtime</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Append element to the end of the linked list</td>\n<td>linkedList.add(element)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Add element at a specific index in the linked list</td>\n<td>linkedList.add(index, element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get element at index in the linked list</td>\n<td>linkedList.get(index)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Remove an element from the linked list</td>\n<td>linkedList.remove(element)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Remove element at a specific index</td>\n<td>linkedList.removeAt(index)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Check if a linked list contains an element</td>\n<td>linkedList.contains(element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Return the linked list in reverse order</td>\n<td>val r = linkedList.reversed()</td>\n<td>O(1) since the list is doubly linked</td>\n</tr>\n</tbody>\n</table>\n<h1>Set</h1>\n<p>A <a href=\"https://kotlinlang.org/docs/collections-overview.html#set\">Set</a> stores unique elements. Like all collections in Kotlin, there are the <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/\">read only set</a> and the <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/\">MutableSet</a>, which offers write access. In some cases the order of a set is not reliable, that is to say that the order of insertion is not maintained. However, the default implementation of a set in Kotlin uses a <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/\">LinkedHashSet</a> so the order of insertion is preserved.</p>\n<h2>Creating a Set</h2>\n<h3>A <code>read only</code> set can be created using the <code>setOf</code> function</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">val mySet = setOf(1, 2, 3, 4) //implicit type declaration\nval mySet2 = setOf&lt;Int&gt;(1, 2, 3, 4) // explicit type declaration</code>\n        </deckgo-highlight-code>\n<h3>A mutable set can be created using the <code>mutableSetOf</code> function</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">val mySet = mutableSetOf(1, 2, 3, 4) //implicit type declaration\nval mySet2 = mutableSetOf&lt;Int&gt;(1, 2, 3, 4) // explicit type declaration\nmySet.add(5)\nmySet.add(3)\nprintln(mySet2) // [1, 2, 3, 4, 5], notice how 4 was not added twice</code>\n        </deckgo-highlight-code>\n<h2>Set Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Runtime</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get the size of the set</td>\n<td>mySet.size</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Add element to the set</td>\n<td>mySet.add(element)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Remove element from set</td>\n<td>mySet.remove(element)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Check if a set contains an element</td>\n<td>mySet.contains(element)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<h1>Map</h1>\n<p>A <a href=\"https://kotlinlang.org/docs/collections-overview.html#map\">Map</a> stores key-value pairs with unique keys. Values in the map can be stored more than once if they are stored under different keys. Similarly to the set, some implementations of this <code>interface</code> do not preserve order, however, the default implementation of <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/\">LinkedHashMap</a> does.</p>\n<h2>Creating a Map</h2>\n<h3>A <code>read only</code> map can be created using the <code>mapOf</code> function</h3>\n<h4>A map will always have a <code>type for the key</code> and a <code>type for the value</code> so it’s important to be mindful of that when explicitly declaring a map.</h4>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">val numsMap = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) //implicit type declaration\nval numsMap2 = mapOf&lt;String, Int&gt;(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) // explicit type declaration\n// The above will create a map of type &lt;String, Int&gt; with the key/values {one=1, two=2, three=3}</code>\n        </deckgo-highlight-code>\n<h3>A mutable map can be created using the <code>mutableMapOf</code> function</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">val numsMap = mutableMapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) //implicit type declaration\nval numsMap2 = mutableMapOf&lt;String, Int&gt;(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) // explicit type \nprintln(numsMap) // {one=1, two=2, three=3}\nnumsMap.put(&quot;five&quot;, 5) // add an entry\nprintln(numsMap) // {one=1, two=2, three=3, five=5}\nprintln(numsMap.get(&quot;three&quot;)) // 3\nnumsMap.remove(&quot;one&quot;) // remove an enrty\nprintln(numsMap) // {two=2, three=3, five=5}</code>\n        </deckgo-highlight-code>\n<h2>Map Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Runtime</th>\n<th>Alternative</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get the size of the map</td>\n<td>myMap.size</td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>Add/modify an entry to the map</td>\n<td>myMap.put(key, value)</td>\n<td>O(1)</td>\n<td>myMap[key] = value</td>\n</tr>\n<tr>\n<td>Remove an entry from the map</td>\n<td>myMap.remove(key)</td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>Check if map contains a key</td>\n<td>myMap.contains(key)</td>\n<td>O(1)</td>\n<td>myMap.contains(key).let {…}</td>\n</tr>\n<tr>\n<td>Check if a map contains a value</td>\n<td>myMap.containsValue(value)</td>\n<td>O(n)</td>\n<td>myMap.containsValue(value).let {…}</td>\n</tr>\n</tbody>\n</table>\n<h1>Heap</h1>\n<p><a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure)\">Heaps</a> are great! There are generally two types of heaps. A min heap which stores the minimum element at the root of the tree, and a max heap which instead stores the largest value at the root. In Kotlin, we can leverage the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html\">PriorityQueue</a> to create this data structure.</p>\n<h2>Creating a Min Heap with a Priority Queue</h2>\n<p>The default implementation of a PriorityQueue actually gives the min heap functionality. Since Kotlin does not support this out of the box, it’s necessary to <code>import java.util.PriorityQueue</code>. Once PriorityQueue is imported, one can be declared as such:</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">import java.util.PriorityQueue\n\nval nums = listOf(5, 2, 4, 1, 3)\nval minHeap = PriorityQueue&lt;Int&gt;() // declare a min heap with int values\nminHeap.addAll(nums) // add elements of a Collection with addAll assuming they are the same type\nprintln(minHeap) // [1, 2, 4, 5, 3]\nminHeap.add(0)\nprintln(minHeap) // [0, 2, 1, 5, 3, 4]\nval min = minHeap.poll() // 0, removes 0 from the heap\nprintln(minHeap) // [1, 2, 4, 5, 3] since 1 is not the smallest value\nval min2 = minHeap.peek() // returns 1 but does not remove it from the heap\nprintln(min2) // 1\nprintln(minHeap) // [1, 2, 4, 5, 3]</code>\n        </deckgo-highlight-code>\n<h2>Creating a Max Heap with a PriorityQueue</h2>\n<p>To turn the PriorityQueue into a max heap, it will be required to pass an instance of <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/\">comparator</a>. Luckily, most of the common comparators can be found <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/\">here</a>. The one that will enable the max heap functionality is the <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/compare-by-descending.html#comparebydescending\">compareByDescending</a> function. This will tell the PriorityQueue to give the highest priority to the largest value.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">import java.util.PriorityQueue\nval nums = listOf(5, 2, 4, 1, 3)\nval maxHeap = PriorityQueue&lt;Int&gt;(compareByDescending{it})\nmaxHeap.addAll(nums)\nprintln(maxHeap) // [5, 3, 4, 1, 2]\nmaxHeap.add(0)\nprintln(maxHeap) // [5, 3, 4, 1, 2, 0]\nval max = maxHeap.poll() // returns and removes 5 from the heap\nprintln(max) // 5\nprintln(maxHeap) // [4, 3, 0, 1, 2]\nval max2 = maxHeap.peek()  // returns 4 but does not remove it from the heap\nprintln(max2) // 4\nprintln(maxHeap) // [4, 3, 0, 1, 2]</code>\n        </deckgo-highlight-code>\n<h2>Heap (PriorityQueue) Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Runtime</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get the size of the heap</td>\n<td>heap.size</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Add element to heap</td>\n<td>heap.add(element)</td>\n<td>O(logn)</td>\n</tr>\n<tr>\n<td>Add a collection of elements to a heap (does not work with arrays)</td>\n<td>heap.addAll(list)</td>\n<td>O(nlogn)</td>\n</tr>\n<tr>\n<td>Return and remove the root of the heap (min/max value)</td>\n<td>heap.poll()</td>\n<td>O(logn) since we will need to re heapify the heap</td>\n</tr>\n<tr>\n<td>Return the root of the heap (min/max)</td>\n<td>heap.peek()</td>\n<td>O(1) as no reconstruction is needed</td>\n</tr>\n<tr>\n<td>Remove a specific element from the heap</td>\n<td>heap.remove(element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Check if an element is present in the heap</td>\n<td>heap.contains(element)</td>\n<td>O(n)</td>\n</tr>\n</tbody>\n</table>\n<h1>Stacks</h1>\n<p>A <a href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\">Stack</a> is a <code>last in, first out</code>, or <code>LIFO</code> for short, data structure. It can be thought of as a stack of plates, where the first plate grabbed is going to be the top-most plate (the one that was added last). Again, Kotlin does not provide an implementation of this out of the box so we must rely on its older brother Java. Java has a <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html\">Stack</a> class but as per the documentation, it is recommended to use an <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html\">ArrayDeque</a> for all stack/queue needs. More information on this decision can be found in <a href=\"https://stackoverflow.com/questions/12524826/why-should-i-use-deque-over-stack\">this thread</a>. Importing<code>import java.util.ArrayDeque</code> is all that’s needed to get started.</p>\n<h2>Creating a Stack</h2>\n<h3>ArrayDeque can be used for both <code>LIFI</code> and <code>FIFO</code> (first-in &#x26; first-out) structures. By always pushing/popping from the front of the stack it’s possible to achieve the desired stack behaviour.</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">import java.util.ArrayDeque\n\nval stack = ArrayDeque&lt;Int&gt;()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nstack.push(4)\nprintln(stack)           // [4, 3, 2, 1]\nprintln(stack.isEmpty()) // false\nprintln(stack.peek())    // 4\nprintln(stack)           // [4, 3, 2, 1]\nprintln(stack.pop())     // 4\nprintln(stack)           // [3, 2, 1]\nstack.push(9)\nprintln(stack)           // --&gt; [9, 3, 2, 1]</code>\n        </deckgo-highlight-code>\n<h2>Stack (ArrayDeque) Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Runtime</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get the size of the stack</td>\n<td>stack.size</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Push element onto the stack</td>\n<td>stack.push(element)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Return and remove a the last element from the stack</td>\n<td>stack.pop()</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Return the last element from the stack (do not remove)</td>\n<td>stack.peek()</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Remove a specific element from the stack</td>\n<td>stack.remove(element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Check if the stack is empty</td>\n<td>stack.isEmpty()</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<h1>Queue</h1>\n<h3>A queue is a <code>first in first out</code> or <code>FIFO</code> for short, data structure, and can be thought of as the average lineup to get into a concert. The first to get there is the first to get out of the queue. <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html\">Queue</a> is an interface that can be implemented by either <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html\">ArrayDeque</a>, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html\">PriorityQueue</a> or <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html\">LinkedList</a> (there are more options but these are by far the most common).</h3>\n<h2>Creating a Queue</h2>\n<h3>Since PriorityQueue will unnecessarily add extra functionality (see heap section above) and the LinkedList is not very cache-friendly, it is advised to use <code>ArrayDeque</code> to implement a queue. To get started importing <code>import java.util.Queue</code> and <code>import java.util.ArrayDeque</code> is required.</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">import java.util.ArrayDeque\nimport java.util.Queue\nval queue: Queue&lt;Int&gt; = ArrayDeque&lt;Int&gt;()\nqueue.add(1)\nqueue.add(2)\nqueue.add(3)\nqueue.add(4)\nprintln(queue) // [1, 2, 3, 4]    \nprintln(queue.isEmpty()) // false\nprintln(queue.peek()) // 1\nprintln(queue) // [1, 2, 3, 4]      \nprintln(queue.poll()) // 1  \nprintln(queue) // [2, 3, 4]\nqueue.add(9) \nprintln(queue) // [2, 3, 4, 9]</code>\n        </deckgo-highlight-code>\n<p>By implementing the interface <code>Queue</code>, there will no longer be access to the methods <code>push</code> and <code>pop</code> like there were in the <code>stack</code> example above.</p>\n<h2>Queue Methods and Runtimes</h2>\n<table>\n<thead>\n<tr>\n<th>Action</th>\n<th>Method</th>\n<th>Runtime</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get the size of the queue</td>\n<td>queue.size</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Add element to the queue</td>\n<td>queue.add(element) or queue.offer(element)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Return and remove a the first element from the queue</td>\n<td>queue.poll()</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Return the first element from the queue (do not remove)</td>\n<td>queue.peek()</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Remove a specific element from the queue</td>\n<td>queue.remove(element)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Check if the stack is empty</td>\n<td>queue.isEmpty()</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<h1>Undirected Graphs</h1>\n<p>There is no default Graph implementation in Kotlin, however, one can easily be createdusing a <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-map/\">HashMap</a> of <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-set/\">HashSets</a>. Essentially, the adjacency list is stored in a HashMap, which holds a HashSet of nodes.</p>\n<h2>Creating a Graph</h2>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"vscode\" line-numbers=\"true\"  >\n          <code slot=\"code\">class Graph&lt;T&gt; {\n    val adjacencyMap: HashMap&lt;T, HashSet&lt;T&gt;&gt; = HashMap()\n    fun addEdge(sourceVertex: T, destinationVertex: T) {\n        // Add edge to source vertex / node.\n        adjacencyMap\n            .computeIfAbsent(sourceVertex) { HashSet() }\n            .add(destinationVertex)\n        // Add edge to destination vertex / node.\n        adjacencyMap\n            .computeIfAbsent(destinationVertex) { HashSet() }\n            .add(sourceVertex)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>The <code>computeIfAbsent</code> will create the edge if it is not present, and add the vertex to that edge. Since it’s using maps/sets behind the scenes, the runtime for adding an edge remains constant with <code>O(1)</code> insertion.</p>","frontmatter":{"title":"Common Data Structures in Kotlin","date":"October 15, 2021","description":"An overview of common data structures, how to use them in Kotlin, and all of their time complexities.","time":15}}},"pageContext":{"slug":"/post-2/","previous":{"fields":{"slug":"/post-1/"},"frontmatter":{"title":"Welcome","categories":["about me"]}},"next":null}},
    "staticQueryHashes": ["3649515864","63159454"]}